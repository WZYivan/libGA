/**
 * @file OfficialWork
 * @author WZYivan (2270060975@qq.com)
 * @brief Algorithms for official work adjustment
 * @version 0.1
 * @date 2026-02-09
 *
 * @copyright Copyright (c) 2026
 *
 */

#ifndef M_libga_official_work
#define M_libga_official_work

#include <vector>
#include <string>

#include <DataFrame/DataFrame.h>

#include <lga/Base>
#include <lga/Math>
#include <lga/Angle>
#include <lga/Linalg>
#include <lga/BoostUtils>

namespace lga
{

    using DataFrame = hmdf::StdDataFrame<size_t>;
    using DataFrameColumnIndices = std::vector<size_t>;

    /**
     * @brief result of single route, contains adjustment dataframe and information
     *
     */
    struct Adjust_Frame_Result
    {
        DataFrame frame;
        DataFrame info_frame;
    };

    namespace param
    {
        struct Official_Work
        {
            struct
            {
                struct
                {
                    std::function<double(double)>
                        /**
                         * @brief `40 * sqrt(l)`, where l is sum of distance
                         */
                        forty_sqrt_l = [](double p_l) -> double
                    {
                        return 40 * std::sqrt(p_l);
                    };
                }
                /**
                 * @brief elevation adjustment
                 */
                elev;

                struct
                {
                    std::function<double(double, double)>
                        /**
                         * @brief `60 * sqrt(n)`, where n is observation number
                         */
                        sixty_sqrt_n = [](double p_n, double p_l) -> double
                    {
                        return 60 * std::sqrt(p_n);
                    };
                }
                /**
                 * @brief traverse adjustment
                 */
                traverse;
            } tolerance;
        };
#if !(M_libga_with_impl)
        /**
         * @brief configurations of algorithms for official work adjustment
         */
        extern const Official_Work official_work;
#endif
    }

    /** @cond */
    namespace internal
    {
        /**
         * @brief refine sum of given range to target
         *
         * @param p_vec
         * @param p_sum
         * @param p_target
         * @param p_precision
         */
        void adjustSumToTarget(
            std::vector<double> &p_vec,
            double p_sum,
            double p_target,
            int p_precision);

        /**
         * @brief automatically invoke given tolerance calculation
         *
         * @param p_vec
         * @param p_fn
         * @return double
         */
        double calcTolerance(
            const std::vector<double> &p_vec,
            std::function<double(double)> p_fn);
    }
    /** @endcond */

    /**
     * @brief elevation adjustment of closed route
     *
     * @param p_distances
     * @param p_diff
     * @param p_beg
     * @param p_correction_precision
     * @param p_tolerance_fn
     * @return Adjust_Frame_Result
     */
    Adjust_Frame_Result
    closedElevAdjust(
        std::vector<double> &p_distances,
        std::vector<double> &p_diff,
        double p_beg,
        int p_correction_precision = 3,
        std::function<double(double)> p_tolerance_fn = param::official_work.tolerance.elev.forty_sqrt_l);

    /**
     * @brief elevation adjustment of attached route
     *
     * @param p_distances
     * @param p_diff
     * @param p_beg
     * @param p_end
     * @param p_correction_precision
     * @param p_tolerance_fn
     * @return Adjust_Frame_Result
     */
    Adjust_Frame_Result
    attachedElevAdjust(
        std::vector<double> &p_distances,
        std::vector<double> &p_diff,
        double p_beg,
        double p_end,
        int p_correction_precision = 3,
        std::function<double(double)> p_tolerance_fn = param::official_work.tolerance.elev.forty_sqrt_l);

    /**
     * @brief traverse adjustment of closed route
     *
     * @param p_left_angle
     * @param p_distance
     * @param p_angle_beg azimuth begin
     * @param p_x_beg
     * @param p_y_beg
     * @param p_angle_correction_precision
     * @param p_distance_correction_precision
     * @param p_tolerance_fn
     * @return Adjust_Frame_Result
     */
    Adjust_Frame_Result
    closedTraverseAdjust(
        std::vector<Angle> &p_left_angle,
        std::vector<double> &p_distance,
        const Angle &p_angle_beg,
        double p_x_beg,
        double p_y_beg,
        int p_angle_correction_precision = 0,
        int p_distance_correction_precision = 2,
        std::function<double(double, double)> p_tolerance_fn = param::official_work.tolerance.traverse.sixty_sqrt_n);

    /**
     * @brief traverse adjustment of connecting route
     *
     * @param p_left_angle
     * @param p_distance
     * @param p_angle_beg azimuth begin
     * @param p_angle_end azimuth end
     * @param p_x_beg
     * @param p_y_beg
     * @param p_x_end
     * @param p_y_end
     * @param p_angle_correction_precision
     * @param p_distance_correction_precision
     * @param p_tolerance_fn
     * @return Adjust_Frame_Result
     */
    Adjust_Frame_Result
    connectingTraverseAdjust(
        std::vector<Angle> &p_left_angle,
        std::vector<double> &p_distance,
        const Angle &p_angle_beg,
        const Angle &p_angle_end,
        double p_x_beg,
        double p_y_beg,
        double p_x_end,
        double p_y_end,
        int p_angle_correction_precision = 0,
        int p_distance_correction_precision = 2,
        std::function<double(double, double)> p_tolerance_fn = param::official_work.tolerance.traverse.sixty_sqrt_n);

    enum Route_Type
    {
        CLOSED_ELEV,
        ATTACHED_ELEV,
        CLOSED_TRA,
        CONNECTING_TRA
    };

    bool frameAssert(Route_Type, const Adjust_Frame_Result &);

    /**
     * @brief result of adjustment of a net
     *
     * @tparam Net
     */
    template <typename Net>
    struct Adjust_Net_Result
    {
        /**
         * @brief adjusted net
         *
         */
        Net net;
        /**
         * @brief error matrix
         *
         */
        Matrix sigma;
        double rmse;
    };

    template <typename Net>
    inline Adjust_Net_Result<Net> netAdjust(Net &p_net, double unit_w = 10.0)
    {
        return {p_net};
    }
}

#include <lga/impl/OfficialWorkElevNet.hpp>

#if (M_libga_with_impl)
#include <lga/impl/OfficialWorkUtils.cpp>
#include <lga/impl/OfficialWorkElevAdjust.cpp>
#include <lga/impl/OfficialWorkTraverseAdjust.cpp>
#endif

#endif
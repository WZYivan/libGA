/**
 * @file Base
 * @author WZYivan (227006975@qq.com)
 * @brief Basic header of libGA, defines macros, namespaces, concepts and enumerable constants
 * @version 0.1.0
 * @date 2026-02-08
 *
 * @copyright Copyright (c) 2026
 *
 */

#ifndef M_libga_base
#define M_libga_base

#include <concepts>

#define M_libga_version_major 0
#define M_libga_version_minor 1
#define M_libga_version_patch 0

#define M_libga_begin \
    namespace lga     \
    {
#define M_libga_end }

#ifdef LGA_HEADER_ONLY
#define M_libga_with_impl (true)
#else
#define M_libga_with_impl (false)
#endif

#include <lga/Error>
#define M_libga_not_impl(P_reason) throw lga::Not_Implement_Error(P_reason)

#ifdef LGA_DEBUG
#define M_libga_debug true
#include <print>
#include <iostream>
#if (__x86_64__)
#define M_libga_b(P_reason) asm("int3");
#endif
#else
#define M_libga_debug false
#define M_libga_b(P_reason)
#endif

#ifdef LGA_HIGH_PRECISION
#define M_libga_hp true
#else
#define M_libga_hp false
#endif

/**
 * @brief root namespace of libGA
 *
 */
namespace lga
{

    /**
     * @brief set a variable to its default construction, it's designed to reset status of variables in `config`
     *
     * @tparam Config variable's type, should to automatically detected
     * @param p_config variable to be reset
     */
    template <typename Config>
    void reset(Config &p_config)
    {
        p_config = Config{};
    }

    /**
     * @brief all concepts are defined here
     *
     */
    namespace concepts
    {
        /**
         * @brief to `T t`, t supports `std::cout << t`
         *
         * @tparam T
         */
        template <typename T>
        concept Can_Output_To_Ostream = requires(T t) {
            { std::cout << t };
        };

        /**
         * @brief to `T t`, t supports function call `t.begin()` and `t.end()`
         *
         * @tparam T
         */
        template <typename T>
        concept Can_Access_Begin_End = requires(T t) {
            t.begin();
            t.end();
        };

        /**
         * @brief `Range r` satisfy such constraints: \n
         * 1. has `.begin()` and .`end()` \n
         * 2. .begin() returns same as .end() \n
         * 3. `operator*` of .begin() returns same as .end() \n
         * 4. `ReturnType` of .begin() is comparable \n
         * 5. `ReturnType` of .begin() supports `operator++`
         *
         * @tparam Range
         */
        template <typename Range>
        concept Iterable = requires(Range r) {
            { r.begin() } -> std::same_as<decltype(r.end())>;
            { *r.begin() } -> std::same_as<decltype(*r.end())>;
            { r.begin()++ } -> std::same_as<decltype(r.begin())>;
            { *(r.begin()++) } -> std::same_as<decltype(*r.begin())>;
            { r.begin() == r.begin() } -> std::same_as<bool>;
        };

        /**
         * @brief `Iter iter` satisfy such constraints: \n
         * 1. *iter is `convertible` to `Tar` \n
         * 2. iter is comparable
         * 3. iter support `operator++`
         *
         * @tparam Iter
         * @tparam Tar
         */
        template <typename Iter, typename Tar>
        concept Iter_Like = requires(Iter iter) {
            { *iter } -> std::convertible_to<Tar>;
            { iter == iter } -> std::same_as<bool>;
            { iter++ } -> std::same_as<Iter>;
        };
    }

    /**
     * @brief constants to indicates status of algorithms those contains iterative process
     *
     */
    enum class Iterative_Algo_Info
    {
        /**
         * @brief everything runs normally
         *
         */
        Success,

        /**
         * @brief failed in running coz threshold constraints are not satisfied
         *
         */
        Not_Converged,

        /**
         * @brief given arguments can't support algorithm to run
         *
         */
        Pre_Unsatisfied
    };

    /**
     * @brief each module stores their compile-time configurable variable here, to module <Header>, there is a variable `Header header` to
     * configure
     *
     */
    namespace config
    {
    }

    /**
     * @brief each module stores their pre-compiled const variable here, to module <Header>, there is a variable `Header header` to
     * access its public member variable as input of corresponding algorithm. Or you can do it yourself as well, it's just hint.
     *
     */
    namespace param
    {
    }

    /**
     * @brief predefined format pattern for class in `lga`
     *
     */
    namespace fmt
    {
    }

    /**
     * @brief all internal implement are defined here, never try to access or modify them
     *
     */
    namespace internal
    {
    }

}

#endif
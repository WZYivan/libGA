#ifndef M_libga_angle
#define M_libga_angle

#include <string>
#include <regex>
#include <tuple>
#include <numbers>
#include <format>
#include <cmath>
#include <stdexcept>
#include <iostream>

#include <lga/Base>

M_libga_begin

    namespace fmt
{
    constexpr std::string_view
        dms{"{:1s}{:03d}d{:02d}m{:.3f}s"},
        ddmmss{"{:1s}{:03d}.{:02d}{:02.0f}"},
        u_dms{"{:0s}{:03d}d{:02d}m{:.3f}s"},
        u_ddmmss{"{:0s}{:03d}.{:02d}{:02.0f}"};
};

namespace config
{
    struct Angle
    {
        std::string_view output_fmt = fmt::dms;
    };
    static inline Angle angle = {};
}

class Angle
{
public:
    explicit constexpr Angle(const double p_rad) : m_radian(p_rad) {}
    Angle() : Angle(0.0) {}
    constexpr Angle(std::initializer_list<double> il);

    constexpr static Angle fromSeconds(double p_seconds);
    constexpr static Angle fromMinutes(double p_minutes);
    constexpr static Angle fromDegrees(double p_degrees);
    constexpr static Angle fromRadian(double p_rad);
    constexpr static Angle fromDMS(double p_d, double p_m, double p_s, bool p_sign = false);
    constexpr double toSeconds() const;
    constexpr double toMinutes() const;
    constexpr double toDegrees() const;
    constexpr double toRadian() const;
    constexpr double seconds() const;
    constexpr int minutes() const;
    constexpr int degrees() const;
    constexpr std::tuple<int, int, double> toDMS() const;

    constexpr static Angle fromString(std::string_view p_str, std::string_view p_pattern = R"(([+-])?(\d{1,}).(\d{2})(\d{1,}))");
    inline std::string toString(std::string_view p_format = fmt::dms) const;

    constexpr double sin() const;
    constexpr double cos() const;
    constexpr double tan() const;
    constexpr double sec() const;
    constexpr double csc() const;
    constexpr double cot() const;

    constexpr Angle operator+(const Angle &) const;
    constexpr Angle operator-(const Angle &) const;
    constexpr Angle operator-() const;
    constexpr friend Angle operator*(const Angle &, double);
    constexpr friend Angle operator*(double, const Angle &);
    constexpr friend Angle operator/(const Angle &, double);
    constexpr friend Angle operator/(double, const Angle &);
    constexpr Angle operator%(const Angle &) const;
    constexpr double operator/(const Angle &) const;

    constexpr bool withinAbs(const Angle &, double p_threshold = 1e-5) const;
    constexpr bool ltAbs(const Angle &, double p_threshold = 1e-5) const;
    constexpr bool gtAbs(const Angle &, double p_threshold = 1e-5) const;
    constexpr bool lt(const Angle &) const;
    constexpr bool gt(const Angle &) const;
    constexpr bool eqApprox(const Angle &, double p_threshold = 1e-5) const;

    constexpr Angle norm() const;
    constexpr Angle normSym() const;
    constexpr Angle abs() const;

    static constexpr Angle zero();
    static constexpr Angle singlePi();
    static constexpr Angle doublePi();

private:
    double m_radian;
};

constexpr double pi = std::numbers::pi;

constexpr double sec2rad(double);
constexpr double min2rad(double);
constexpr double deg2rad(double);
constexpr double rad2sec(double);
constexpr double rad2min(double);
constexpr double rad2deg(double);

namespace internal
{
    constexpr std::array<double (*)(double), 3> angle_converters{&deg2rad, &min2rad, &sec2rad};
}

template <typename Iter>
constexpr double dms2rad(Iter p_begin, Iter p_end)
    requires std::convertible_to<decltype(*p_begin), double>
{
    size_t size = std::distance(p_begin, p_end);
    if (!(size >= 0 && size <= 3))
    {
        throw std::range_error("dms range size must be [1,3]");
    }
    if (size == 0)
    {
        return 0.0;
    }

    double rad{0.0};
    auto converter_iter = internal::angle_converters.begin();
    bool sign = std::signbit(*p_begin);

    while (size-- != 0)
    {
        rad += (*(converter_iter++))(std::abs(*(p_begin++)));
    }

    return rad * (sign ? -1 : 1);
}

constexpr double dms2rad(double p_d, double p_m, double p_s)
{
    std::array<double, 3> dms{p_d, p_m, p_s};
    return dms2rad(dms.begin(), dms.end());
}

inline std::ostream &operator<<(std::ostream &os, const Angle &angle)
{
    os << angle.toString(config::angle.output_fmt);
    return os;
}

M_libga_end

#include <lga/impl/Angle.hpp>

#endif
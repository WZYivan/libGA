#ifndef M_libga_angle
#define M_libga_angle

#include <string>
#include <regex>
#include <tuple>
#include <numbers>
#include <format>
#include <cmath>
#include <stdexcept>
#include <iostream>

#include <lga/Base>

M_libga_begin

    namespace fmt
{
    inline const std::string_view
        dms{"{:1s}{:03d}d{:02d}m{:.3f}s"},
        ddmmss{"{:1s}{:03d}.{:02d}{:02.0f}"},
        u_dms{"{:0s}{:03d}d{:02d}m{:.3f}s"},
        u_ddmmss{"{:0s}{:03d}.{:02d}{:02.0f}"};
}

namespace config
{
    struct Angle
    {
        std::string_view output_fmt = fmt::dms;
    };
    static inline Angle angle = {};
}

class Angle;

namespace internal
{
    struct Angle_Format_Wrapper
    {
        const Angle &angle;
        std::string_view fmt;
    };

    std::ostream &operator<<(std::ostream &os, const Angle_Format_Wrapper &p_afw);
}

class Angle
{
public:
    explicit Angle(const double p_rad) : m_radian(p_rad) {}
    Angle() : Angle(0.0) {}
    Angle(std::initializer_list<double> il);

    static Angle fromSeconds(double p_seconds);
    static Angle fromMinutes(double p_minutes);
    static Angle fromDegrees(double p_degrees);
    static Angle fromRadian(double p_rad);
    static Angle fromDMS(double p_d, double p_m, double p_s, bool p_sign = false);
    double toSeconds() const;
    double toMinutes() const;
    double toDegrees() const;
    double toRadian() const;
    double seconds() const;
    int minutes() const;
    int degrees() const;
    std::tuple<int, int, double> toDMS() const;

    static Angle fromString(std::string_view p_str, std::string_view p_pattern = R"(([+-])?(\d{1,}).(\d{2})(\d{1,}))");
    std::string toString(std::string_view p_format = fmt::dms) const;

    double sin() const;
    double cos() const;
    double tan() const;
    double sec() const;
    double csc() const;
    double cot() const;

    Angle operator+(const Angle &) const;
    Angle operator-(const Angle &) const;
    Angle operator-() const;
    friend Angle operator*(const Angle &, double);
    friend Angle operator*(double, const Angle &);
    friend Angle operator/(const Angle &, double);
    friend Angle operator/(double, const Angle &);
    Angle operator%(const Angle &) const;
    double operator/(const Angle &) const;

    bool withinAbs(const Angle &, double p_threshold = 1e-5) const;
    bool ltAbs(const Angle &, double p_threshold = 1e-5) const;
    bool gtAbs(const Angle &, double p_threshold = 1e-5) const;
    bool lt(const Angle &) const;
    bool gt(const Angle &) const;
    bool eqApprox(const Angle &, double p_threshold = 1e-5) const;

    Angle norm() const;
    Angle normSym() const;
    Angle std() const;
    Angle abs() const;

    static Angle zero();
    static Angle singlePi();
    static Angle doublePi();

    internal::Angle_Format_Wrapper format(std::string_view p_fmt) const noexcept;

private:
    double m_radian;
};

double sec2rad(double);
double min2rad(double);
double deg2rad(double);
double rad2sec(double);
double rad2min(double);
double rad2deg(double);

#if !(M_libga_with_impl)
namespace internal
{
    extern const double pi;
    extern const std::array<double (*)(double), 3> angle_converters;
}
#endif

template <typename Iter>
double dms2rad(Iter p_begin, Iter p_end)
    requires std::convertible_to<decltype(*p_begin), double>
{
    size_t size = std::distance(p_begin, p_end);
    if (!(size >= 0 && size <= 3))
    {
        throw std::range_error("dms range size must be [1,3]");
    }
    if (size == 0)
    {
        return 0.0;
    }

    double rad{0.0};
    auto converter_iter = internal::angle_converters.begin();
    bool sign = std::signbit(*p_begin);

    while (size-- != 0)
    {
        rad += (*(converter_iter++))(std::abs(*(p_begin++)));
    }

    return rad * (sign ? -1 : 1);
}

double dms2rad(double p_d, double p_m, double p_s);

inline std::ostream &operator<<(std::ostream &os, const Angle &angle)
{
    os << angle.toString(config::angle.output_fmt);
    return os;
}

M_libga_end

#if (M_libga_with_impl)
#include <lga/impl/Angle.cpp>
#endif

#endif
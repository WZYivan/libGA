/**
 * @file Angle
 * @author WZYivan (2270060975@qq.com)
 * @brief sexagesimal angle calculation support
 * @version 0.1
 * @date 2026-02-08
 *
 * @copyright Copyright (c) 2026
 *
 */

#ifndef M_libga_angle
#define M_libga_angle

#include <string>
#include <regex>
#include <tuple>
#include <numbers>
#include <format>
#include <cmath>
#include <stdexcept>
#include <iostream>

#include <lga/Base>

namespace lga
{
    namespace fmt
    {
        inline const std::string_view
            /**
             * @brief "-1d2m3s"
             *
             */
            dms{"{:1s}{:03d}d{:02d}m{:.3f}s"},
            /**
             * @brief -001.0203
             *
             */
            ddmmss{"{:1s}{:03d}.{:02d}{:02.0f}"},
            /**
             * @brief 1d2m3s
             *
             */
            u_dms{"{:0s}{:03d}d{:02d}m{:.3f}s"},
            /**
             * @brief 001.0203
             *
             */
            u_ddmmss{"{:0s}{:03d}.{:02d}{:02.0f}"},
            /**
             * @brief [-1, 2, 3]
             *
             */
            json_array{"[{:1s}{:d}, {:2d}, {:.3f}]"};
    }

    namespace config
    {
        struct Angle
        {
            /**
             * @brief output foramt of `operator<<`
             * @see operator<<
             *
             */
            std::string_view output_fmt = fmt::dms;
        };

        /**
         * @brief configuration of class `Angle`
         * @see Angle
         *
         */
        static inline Angle angle = {};
    }

    class Angle;

    namespace internal
    {
        /**
         * @brief wrap a ref to `Angle` with its output format
         * @see Angle
         */
        struct Angle_Format_Wrapper
        {
            const Angle &angle;   ///< @private
            std::string_view fmt; ///< @private
        };

        std::ostream &operator<<(std::ostream &os, const Angle_Format_Wrapper &p_afw);
    }

    /**
     * @brief sexagesimal angle, stored in radian
     *
     */
    class Angle
    {
    public:
        /**
         * @brief construct a new Angle object in radian
         *
         * @param p_rad
         */
        explicit Angle(const double p_rad) : m_radian(p_rad) {}

        /**
         * @brief default construction using `0.0`
         *
         */
        Angle() : Angle(0.0) {}

        /**
         * @brief construct a new Angle object using range
         *
         * @param il [d <, m, s>]
         * @throw std::range_error
         * @see dms2rad
         */
        Angle(std::initializer_list<double> il);

        /**
         * @brief construct Angle in second
         *
         * @param p_seconds
         * @return Angle
         */
        static Angle fromSeconds(double p_seconds);

        /**
         * @brief construct Angle in minute
         *
         * @param p_minutes
         * @return Angle
         */
        static Angle fromMinutes(double p_minutes);

        /**
         * @brief construct Angle in degree
         *
         * @param p_degrees
         * @return Angle
         */
        static Angle fromDegrees(double p_degrees);

        /**
         * @brief construct Angle in radian
         *
         * @param p_rad
         * @return Angle
         */
        static Angle fromRadian(double p_rad);

        /**
         * @brief construct Angle in (sign)[d, m, s]
         *
         * @param p_d abs of degree
         * @param p_m abs of minute
         * @param p_s abs of second
         * @param p_sign sign of degree
         * @return Angle
         */
        static Angle fromDMS(double p_d, double p_m, double p_s, bool p_sign = false);

        /**
         * @brief convert to seconds
         *
         * @return double
         */
        double toSeconds() const;

        /**
         * @brief convert to minutes
         *
         * @return double
         */
        double toMinutes() const;

        /**
         * @brief convert to degrees
         *
         * @return double
         */
        double toDegrees() const;

        /**
         * @brief convert to radian
         *
         * @return double
         */
        double toRadian() const;

        /**
         * @brief get second part
         *
         * @return double
         */
        double seconds() const;

        /**
         * @brief get minute part
         *
         * @return int
         */
        int minutes() const;

        /**
         * @brief get degree part without sign
         *
         * @return int
         */
        int degrees() const;

        /**
         * @brief get (d, m, s) without sign
         *
         * @return std::tuple<int, int, double>
         */
        std::tuple<int, int, double> toDMS() const;

        /**
         * @brief parse Angle from string following given pattern
         *
         * @param p_str string to be parsed
         * @param p_pattern regex pattern
         * @return Angle
         */
        static Angle fromString(std::string_view p_str, std::string_view p_pattern = R"(([+-])?(\d{1,}).(\d{2})(\d{1,}))");

        /**
         * @brief format to string in given pattern
         *
         * @param p_format pattern
         * @return std::string
         */
        std::string toString(std::string_view p_format = fmt::dms) const;

        /**
         * @brief sin(rad)
         *
         * @return double
         */
        double sin() const;

        /**
         * @brief cos(rad)
         *
         * @return double
         */
        double cos() const;

        /**
         * @brief tan(rad)
         *
         * @return double
         */
        double tan() const;

        /**
         * @brief sec(rad)
         *
         * @return double
         */
        double sec() const;

        /**
         * @brief csc(rad)
         *
         * @return double
         */
        double csc() const;

        /**
         * @brief cot(rad)
         *
         * @return double
         */
        double cot() const;

        /**
         * @brief plus
         *
         * @return Angle
         */
        Angle operator+(const Angle &) const;

        /**
         * @brief substraction
         *
         * @return Angle
         */
        Angle operator-(const Angle &) const;

        /**
         * @brief negative
         *
         * @return Angle
         */
        Angle operator-() const;

        /**
         * @brief multiply by constants
         *
         * @return Angle
         */
        friend Angle operator*(const Angle &, double);

        /**
         * @brief multiply by constants
         *
         * @return Angle
         */
        friend Angle operator*(double, const Angle &);

        /**
         * @brief divide by constants
         *
         * @return Angle
         */
        friend Angle operator/(const Angle &, double);

        /**
         * @brief divide by constants
         *
         * @return Angle
         */
        friend Angle operator/(double, const Angle &);

        /**
         * @brief mod its radian by another's
         *
         * @return Angle
         */
        Angle operator%(const Angle &) const;

        /**
         * @brief divide its radian by another's
         *
         * @return double
         */
        double operator/(const Angle &) const;

        /**
         * @brief two angle absolute difference is within threshold
         *
         * @param p_threshold
         * @return true
         * @return false
         */
        bool withinAbs(const Angle &, double p_threshold = 1e-5) const;

        /**
         * @brief its absolute radian less than another's
         *
         * @param p_threshold
         * @return true
         * @return false
         */
        bool ltAbs(const Angle &, double p_threshold = 1e-5) const;

        /**
         * @brief its absolute radian greater than another's
         *
         * @param p_threshold
         * @return true
         * @return false
         */
        bool gtAbs(const Angle &, double p_threshold = 1e-5) const;

        /**
         * @brief its radian less than another's
         *
         * @param p_threshold
         * @return true
         * @return false
         */
        bool lt(const Angle &) const;

        /**
         * @brief its radian greater than another's
         *
         * @param p_threshold
         * @return true
         * @return false
         */
        bool gt(const Angle &) const;

        /**
         * @brief two angles are approximately equals to each other
         *
         * @param p_threshold
         * @return true
         * @return false
         * @see withinAbs
         */
        bool eqApprox(const Angle &, double p_threshold = 1e-5) const;

        /**
         * @brief standardize to (0, 360) degree
         *
         * @return Angle
         */
        Angle std() const;

        /**
         * @brief absolute value of radian
         *
         * @return Angle
         */
        Angle abs() const;

        /**
         * @brief 0 degree
         *
         * @return Angle
         */
        static Angle zero();

        /**
         * @brief 180 degree
         *
         * @return Angle
         */
        static Angle singlePi();

        /**
         * @brief 360 degree
         *
         * @return Angle
         */
        static Angle doublePi();

        /**
         * @brief wrap itself with a output format to a new object can output to `std::ostream`
         *
         * @param p_fmt
         * @return internal::Angle_Format_Wrapper
         */
        internal::Angle_Format_Wrapper format(std::string_view p_fmt) const noexcept;

    private:
        double m_radian;
    };

    /**
     * @brief convert second to radian
     *
     * @return double
     */
    double sec2rad(double);

    /**
     * @brief convert minute to radian
     *
     * @return double
     */
    double min2rad(double);

    /**
     * @brief convert degree to radian
     *
     * @return double
     */
    double deg2rad(double);

    /**
     * @brief convert radian to second
     *
     * @return double
     */
    double rad2sec(double);

    /**
     * @brief convert radian to minute
     *
     * @return double
     */
    double rad2min(double);

    /**
     * @brief convert radian to degree
     *
     * @return double
     */
    double rad2deg(double);

#if !(M_libga_with_impl)
    namespace internal
    {
        /**
         * @brief alias of `std::numbers::pi`
         *
         */
        extern const double pi;

        /**
         * @brief [deg2rad, min2rad, sec2rad]
         *
         */
        extern const std::array<double (*)(double), 3> angle_converters;
    }
#endif

    /**
     * @brief convert a range to radian in order of [d, m, s]
     *
     * @tparam Iter
     * @param p_begin
     * @param p_end
     * @return double
     * @throw std::range_error if range size not in [1, 3]
     */
    template <typename Iter>
        requires concepts::Iter_Like<Iter, double>
    inline double dms2rad(Iter p_begin, Iter p_end);

    /**
     * @brief build a array [d, m, s] and invoke dms2rad(begin, end)
     *
     * @see dms2rad
     * @param p_d
     * @param p_m
     * @param p_s
     * @return double
     */
    double dms2rad(double p_d, double p_m, double p_s);

    /**
     * @brief output `Angle` to `ostream`
     * @see Angle
     * @param os
     * @param angle
     * @return std::ostream&
     */
    inline std::ostream &operator<<(std::ostream &os, const Angle &angle);
}

#include <lga/impl/Angle.hpp>

#if (M_libga_with_impl)
#include <lga/impl/Angle.cpp>
#endif

#endif